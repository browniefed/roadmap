var RoadmapConstants = require('./RoadmapConstants'),
    Proxy = require('roadmapper/data/Proxy'),
    JamaItemProxy = require('roadmapper/data/JamaItemProxy'),
    _ = require('lodash'),
    when = require('when');

//Proxy actions should return promises that then resolve and always be async
var RoadmapActions = {
    saveRoadmap: function(payload) {
        Proxy.saveRoadmap(payload.id, payload.roadmap);
        // this.dispatch(RoadmapConstants.ROADMAP_SAVE_ROADMAP, payload);
    },
    loadItemsForRoadmap: function(payload) {
        var roadmap = Proxy.getRoadmap(payload.roadmapId);

        JamaItemProxy.getChildren(payload.jamaApiId, _.bind(function(err, res) {
            payload.items = res.body.data;

            var itemTypes = _.uniq(_.pluck(res.body.data, 'itemType'));
            JamaItemProxy.getItemType(itemTypes[0], _.bind(function(err, res) {

                var groupableFields = _.filter(res.body.data.fields, function(field) {
                    return (field.fieldType == 'RELEASE' || field.fieldType == 'LOOKUP');
                });
                
                payload.groupableFields = groupableFields;
                payload.itemTypes = res.body.data;

                var promises = [];
                _.each(groupableFields, function(groupField) {

                    if (groupField.fieldType === 'LOOKUP') {
                        var defer = when.defer();

                        JamaItemProxy.getPicklistOptions(groupField.pickList, function(err, res) {
                            defer.resolve({
                                field: groupField.name,
                                options: res
                            });
                        });

                        promises.push(defer.promise);
                    }

                });

                var releaseDefer = when.defer();

                JamaItemProxy.getAllReleases(roadmap.jamaProjectId, function(err, res) {
                    releaseDefer.resolve(res)
                });

                promises.unshift(releaseDefer.promise);

                when.all(promises).then(_.bind(function(pickListOptions) {
                    payload.releases = pickListOptions.shift();
                    payload.pickListOptions = _.indexBy(pickListOptions, 'field')

                    this.dispatch(RoadmapConstants.ROADMAP_ADD_ITEMS_TO_ROADMAP, payload);
                }, this));
                
            }, this))
        }, this))
    },
    loadCommentsForItem: function(payload) {
        JamaItemProxy.loadCommentsForItem(payload.id, _.bind(function(err, res) {
            this.dispatch(RoadmapConstants.ROADMAP_LOAD_ITEM_COMMENTS_COMPLETE, res)
        }, this));
    },
    createRoadmap: function(payload) {
        var roadmapId = Proxy.createRoadmap(payload);
        payload.items = [];
        this.dispatch(RoadmapConstants.ROADMAP_CREATE_ROADMAP, payload);
        if (payload.selectedItem) {
          setTimeout(_.bind(function() {
            this.flux.actions.RoadmapActions.loadItemsForRoadmap({
                roadmapId: roadmapId,
                jamaApiId: payload.selectedItem.id
            })
        }, this), 0)  
        }
        
    },
    deleteRoadmap: function(payload) {
        Proxy.deleteRoadmap(payload.roadmapId);
        this.dispatch(RoadmapConstants.ROADMAP_DELETE_ROADMAP, payload);
    },
    refreshItems: function(payload) {

        var promises = _.map(payload.items, function(item) {
            var defer = when.defer();
            JamaItemProxy.getItem(item.id, _.bind(function(err, res) {
                var updateItem = {
                    item: res.body.data,
                    roadmapId: payload.roadmapId
                };
                defer.resolve(updateItem);
            }, this));
            return defer.promise;
        }, this)

        when.all(promises).then(_.bind(function(items) {
            this.dispatch(RoadmapConstants.ROADMAP_UPDATE_ROADMAP_ITEM, items);
        }, this));
    },
    updateJamaItem: function(payload) {
        var updateItem = {
            fields: _.omit.apply(_, [payload.item.fields].concat(payload.removeFields || []))
        };

        JamaItemProxy.updateItem(payload.id, updateItem, _.bind(function(err, res) {
            this.dispatch(RoadmapConstants.ROADMAP_UPDATE_JAMA_ITEM, payload);
        }, this));
    }
}

module.exports = RoadmapActions;